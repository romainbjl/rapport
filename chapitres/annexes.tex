\section{Annexes}
	\subsection{Webographie}
		\vspace{0.3cm}
		\begin{itemize}
			\item[$\bullet$] Lorraine Data Network : \url{http://ldn-fai.net/}

			\item[$\bullet$] Services LDN : \url{http://ldn-fai.net/services-de-lassociation/}

			\item[$\bullet$] Wiki LDN : \url{https://wiki.ldn-fai.net}

			\item[$\bullet$] Documentation libvirt sur les interfaces réseaux : \url{http://libvirt.org/formatnetwork.html}

			\item[$\bullet$] Zabbix : \url{http://zabbix.com/}

			\item[$\bullet$] Document de Zabbix : \url{https://www.zabbix.com/documentation/doku.php?id=2.2/manual}

			\item[$\bullet$] Document réseau libvirt : \url{http://libvirt.org/formatnetwork.html}

			\item[$\bullet$] Tutoriel KVM/libvirt : \url{http://homeserver-diy.net/wiki/index.php?title=Virtualisation_avec_KVM_via_libvirt}

			\item[$\bullet$] Article sur TC : \url{http://linuxfr.org/wiki/une-introduction-au-controle-du-trafic-reseau-avec-linux}
		\end{itemize}

\newpage

\section{Lexique}
	\vspace{0.3cm}

	LDN : Lorraine Data Network est une association pour la défense d'un Internet libre, neutre et décentralisé situé en Lorraine.\\

	95\up{ème} centile : La mesure du 95\up{ème} centile est celle utilisée par les opérateurs sur Internet pour facturer la consommation de bande passante de leurs clients. Le 95\up{ème} centile est la valeur telle que 95\% des valeurs sont en dessous et 5\% sont au dessus.\\

	API Zabbix : Outil de Zabbix, utilisé pour étendre Zabbix à d'autres applications pour une plateforme ou pour l'intégration à un logiciel.\\

	JSON-RPC : Protocole permettant la définition de plusieurs types de données et de commandes. JSON-RPC permet d'effectuer des requêtes à un serveur pour obtenir des informations systèmes ou des éléments de base de données.\\

	FAI : Un Fournisseur d'Accès à Internet est un organisme offrant une connexion à Internet.\\

	FSI : Fournisseur de Services Internet, organisme qui offre des solutions disponible depuis l'internet (ex : hébergement).\\

	RRD : Round-Robin Database est une base de donnée pour la génération de graphique.\\

	Peering : Le peering est la pratique d'échanger du trafic Internet avec des pairs.\\

\newpage

	\subsection{Schéma réseau simplifié}

		\subsubsection{\label{schemaReseau0}Premier schéma}

	\vspace{-0.2cm}	
	\begin{center}
		\includegraphics[scale=0.65]{schemaReseau0.png}
	\end{center}

\newpage
		\subsubsection{\label{schemaReseau1}Second schéma}

	\vspace{-0.3cm}	
	\begin{center}
		\includegraphics[scale=0.82]{schemaReseau1.png}
	\end{center}

\newpage


	\subsection{\label{xmlVm0}Exemple xml de vm}
	\vspace{0.3cm}
\begin{verbatim}
<!--
WARNING: THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE 
OVERWRITTEN AND LOST. Changes to this xml configuration should be made using:
  virsh edit vm0
or other application using the libvirt API.
-->

<domain type='kvm'>
  <name>vm0</name>
  <uuid>26e7e9a0-5798-bac6-84e6-2745edc2c24a</uuid>
  <memory unit='KiB'>1048576</memory>
  <currentMemory unit='KiB'>1048576</currentMemory>
  <vcpu placement='static'>1</vcpu>
  <os>
    <type arch='x86_64' machine='pc-1.1'>hvm</type>
    <boot dev='hd'/>
  </os>
  <features>
    <acpi/>
    <apic/>
    <pae/>
  </features>
  <clock offset='utc'/>
  <on_poweroff>destroy</on_poweroff>
  <on_reboot>restart</on_reboot>
  <on_crash>restart</on_crash>
  <devices>
    <emulator>/usr/bin/kvm</emulator>
    <disk type='file' device='disk'>
      <driver name='qemu' type='raw'/>
      <source file='/var/lib/libvirt/images/vm2.img'/>
      <target dev='vda' bus='virtio'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/>
    </disk>
    <disk type='block' device='cdrom'>
      <driver name='qemu' type='raw'/>
      <target dev='hdc' bus='ide'/>
      <readonly/>
      <address type='drive' controller='0' bus='1' target='0' unit='0'/>
    </disk>
    <controller type='usb' index='0'>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x2'/>
    </controller>
    <controller type='ide' index='0'>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x1'/>
    </controller>
    <interface type='bridge'>
      <mac address='52:54:00:ef:6e:27'/>
      <source bridge='virbr0'/>
      <model type='virtio'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/>
    </interface>
    <serial type='pty'>
      <target port='0'/>
    </serial>
    <console type='pty'>
      <target type='serial' port='0'/>
    </console>
    <input type='tablet' bus='usb'/>
    <input type='mouse' bus='ps2'/>
\end{verbatim}
\begin{verbatim}
    <graphics type='vnc' port='-1' autoport='yes'/>
    <video>
      <model type='cirrus' vram='9216' heads='1'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x0'/>
    </video>
    <memballoon model='virtio'>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x05' function='0x0'/>
    </memballoon>
  </devices>
</domain>
\end{verbatim}

\newpage

	\subsection{\label{routeVm0}Les différentes tables de routage}
		\subsubsection{Vm0}
		\vspace{0.3cm}

\begin{verbatim}
Table de routage IP du noyau
Destination     Passerelle      Genmask         Indic Metric Ref    Use Iface
0.0.0.0         172.16.90.41    0.0.0.0         UG    0      0        0 eth0
172.16.90.41    0.0.0.0         255.255.255.255 UH    0      0        0 eth0

Table de routage IPv6 du noyau
Destination                    Next Hop                   Flag Met Ref Use If
fc01:42::/64                   ::                         U    256 0     0 eth0
fe80::/64                      ::                         U    256 0     0 eth0
::/0                           fe80::42                   UG   1024 0     0 eth0
::/0                           ::                         !n   -1  1     1 lo
::1/128                        ::                         Un   0   1     2 lo
fc01:42::1/128                 ::                         Un   0   1     0 lo
fe80::5054:ff:feef:6e27/128    ::                         Un   0   1     0 lo
ff00::/8                       ::                         U    256 0     0 eth0
::/0                           ::                         !n   -1  1     1 lo
\end{verbatim}

\newpage

		\subsubsection{\label{routeServices}Services}
		\vspace{0.3cm}

\begin{verbatim}
Table de routage IP du noyau
Destination     Passerelle      Genmask         Indic Metric Ref    Use Iface
0.0.0.0         192.168.1.254   0.0.0.0         UG    0      0        0 eth0
10.200.0.0      172.16.90.40    255.255.0.0     UG    0      0        0 eth1
172.16.90.40    0.0.0.0         255.255.255.254 U     0      0        0 eth1
172.16.91.1     0.0.0.0         255.255.255.255 UH    0      0        0 vnet0
172.16.91.2     0.0.0.0         255.255.255.255 UH    0      0        0 vnet1
192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0
192.168.122.0   0.0.0.0         255.255.255.0   U     0      0        0 virbr0

Table de routage IPv6 du noyau
Destination                    Next Hop                   Flag Met Ref Use If
fc00::1:0/112                  ::                         U    256 0     3 eth1
fc01:42::/64                   ::                         U    1024 0     0 vnet0
fc01:1337::/64                 ::                         U    1024 0     0 vnet1
fcee::/16                      fc00::1:1                  UG   1024 0     0 eth1
fe80::/64                      ::                         U    256 0     0 eth0
fe80::/64                      ::                         U    256 0     0 eth1
fe80::/64                      ::                         U    256 0     0 vnet1
fe80::/64                      ::                         U    256 0     0 vnet0
fe80::/64                      ::                         U    256 0     0 vnet2
::/0                           ::                         !n   -1  1   997 lo
::1/128                        ::                         Un   0   1 61359 lo
fc00::1:0/128                  ::                         Un   0   1     0 lo
fc00::1:2/128                  ::                         Un   0   1   290 lo
fe80::/128                     ::                         Un   0   1     0 lo
fe80::/128                     ::                         Un   0   1     0 lo
fe80::/128                     ::                         Un   0   1     0 lo
fe80::/128                     ::                         Un   0   1     0 lo
fe80::/128                     ::                         Un   0   1     0 lo
fe80::42/128                   ::                         Un   0   1     4 lo
fe80::42/128                   ::                         Un   0   1     3 lo
fe80::21e:4fff:fed1:d08f/128   ::                         Un   0   1     0 lo
fe80::240:5ff:fea6:e841/128    ::                         Un   0   1    24 lo
fe80::fc54:ff:fe24:2036/128    ::                         Un   0   1     0 lo
fe80::fc54:ff:fe64:7e1c/128    ::                         Un   0   1     0 lo
fe80::fc54:ff:feef:6e27/128    ::                         Un   0   1     0 lo
ff00::/8                       ::                         U    256 0     0 eth0
ff00::/8                       ::                         U    256 0     0 eth1
ff00::/8                       ::                         U    256 0     0 vnet1
ff00::/8                       ::                         U    256 0     0 vnet0
ff00::/8                       ::                         U    256 0     0 vnet2
::/0                           ::                         !n   -1  1   997 lo
\end{verbatim}

\newpage

		\subsubsection{\label{routeRouter}Router}
		\vspace{0.3cm}

\begin{verbatim}
Table de routage IP du noyau
Destination     Passerelle      Genmask         Indic Metric Ref    Use Iface
10.42.0.2       0.0.0.0         255.255.255.254 U     0      0        0 eth0
172.16.90.40    0.0.0.0         255.255.255.254 U     0      0        0 eth1
172.16.91.0     172.16.90.41    255.255.255.0   UG    0      0        0 eth1

Table de routage IPv6 du noyau
Destination                    Next Hop                   Flag Met Ref Use If
fc00::1:0/112                  ::                         U    256 0     5 eth1
fc01::/16                      fc00::1:2                  UG   1024 0     0 eth1
fcab::/112                     ::                         U    256 0     0 eth0
fe80::/64                      ::                         U    256 0     0 eth1
fe80::/64                      ::                         U    256 0     0 eth0
::/0                           ::                         !n   -1  1    48 lo
::1/128                        ::                         Un   0   1    31 lo
fc00::1:0/128                  ::                         Un   0   1     0 lo
fc00::1:1/128                  ::                         Un   0   1    15 lo
fcab::/128                     ::                         Un   0   1     0 lo
fcab::2/128                    ::                         Un   0   1     0 lo
fe80::/128                     ::                         Un   0   1     0 lo
fe80::/128                     ::                         Un   0   1     0 lo
fe80::206:29ff:fe4f:259/128    ::                         Un   0   1    18 lo
fe80::218:8bff:fe20:ecbb/128   ::                         Un   0   1     0 lo
ff00::/8                       ::                         U    256 0     0 eth1
ff00::/8                       ::                         U    256 0     0 eth0
::/0                           ::                         !n   -1  1    48 lo
\end{verbatim}

\newpage

		\subsubsection{\label{routeASRALL}PC ASRALL}
		\vspace{0.3cm}

\begin{verbatim}
Table de routage IP du noyau
Destination     Passerelle      Genmask         Indic Metric Ref    Use Iface
0.0.0.0         192.168.1.254   0.0.0.0         UG    0      0        0 eth1
10.42.0.2       0.0.0.0         255.255.255.254 U     0      0        0 eth1
172.16.0.0      10.42.0.3       255.255.0.0     UG    0      0        0 eth1
192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth1
Table de routage IPv6 du noyau
Destination                    Next Hop                   Flag Met Ref Use If
fe80::/64                      ::                         U    256 0     0 peth1
fe80::/64                      ::                         U    256 0     0 eth1
::/0                           ::                         !n   -1  1     7 lo
::1/128                        ::                         Un   0   1  3026 lo
fe80::f24d:a2ff:fe2c:8ddd/128  ::                         Un   0   1     0 lo
fe80::f24d:a2ff:fe2c:8ddd/128  ::                         Un   0   1     0 lo
ff00::/8                       ::                         U    256 0     0 peth1
ff00::/8                       ::                         U    256 0     0 eth1
::/0                           ::                         !n   -1  1     7 lo
\end{verbatim}

\newpage

		\subsection{\label{newRoute}Les nouvelles routes}
			\subsubsection{Router}
			\vspace{0.3cm}

\begin{verbatim}
Table de routage IP du noyau
Destination     Passerelle      Genmask         Indic Metric Ref    Use Iface
10.42.0.2       0.0.0.0         255.255.255.254 U     0      0        0 eth0.800
10.43.0.2       0.0.0.0         255.255.255.254 U     0      0        0 eth0.267
10.200.42.0     10.42.0.2       255.255.254.0   UG    0      0        0 eth0.800
172.16.90.40    0.0.0.0         255.255.255.254 U     0      0        0 eth1
172.16.91.0     172.16.90.41    255.255.255.0   UG    0      0        0 eth1

Table de routage IPv6 du noyau
Destination                    Next Hop                   Flag Met Ref Use If
fc00::1:0/112                  ::                         U    256 0     1 eth1
fc01::/16                      fc00::1:2                  UG   1024 0     0 eth1
fcab::/112                     ::                         U    256 0     4 eth0
fcee:dead:babe::/64            fcab::1                    UG   1024 0     0 eth0
fe80::/64                      ::                         U    256 0     0 eth0
fe80::/64                      ::                         U    256 0     0 eth0.267
fe80::/64                      ::                         U    256 0     0 eth0.800
fe80::/64                      ::                         U    256 0     0 eth1
::/0                           ::                         !n   -1  1    10 lo
::1/128                        ::                         Un   0   1    68 lo
fc00::1:0/128                  ::                         Un   0   1     0 lo
fc00::1:1/128                  ::                         Un   0   1     0 lo
fcab::/128                     ::                         Un   0   1     0 lo
fcab::2/128                    ::                         Un   0   1     0 lo
fe80::/128                     ::                         Un   0   1     0 lo
fe80::/128                     ::                         Un   0   1     0 lo
fe80::/128                     ::                         Un   0   1     0 lo
fe80::/128                     ::                         Un   0   1     0 lo
fe80::206:29ff:fe4f:259/128    ::                         Un   0   1     0 lo
fe80::218:8bff:fe20:ecbb/128   ::                         Un   0   1     0 lo
fe80::218:8bff:fe20:ecbb/128   ::                         Un   0   1     0 lo
fe80::218:8bff:fe20:ecbb/128   ::                         Un   0   1     0 lo
ff00::/8                       ::                         U    256 0     0 eth0
ff00::/8                       ::                         U    256 0     0 eth0.267
ff00::/8                       ::                         U    256 0     0 eth0.800
ff00::/8                       ::                         U    256 0     0 eth1
::/0                           ::                         !n   -1  1    10 lo
\end{verbatim}

\newpage

			\subsubsection{PC ASRALL}
			\vspace{0.3cm}

\begin{verbatim}
Table de routage IP du noyau
Destination     Passerelle      Genmask         Indic Metric Ref    Use Iface
0.0.0.0         192.168.1.254   0.0.0.0         UG    0      0        0 eth1
10.42.0.2       0.0.0.0         255.255.255.254 U     0      0        0 eth0.800
10.43.0.2       0.0.0.0         255.255.255.254 U     0      0        0 eth0.267
172.16.0.0      10.42.0.3       255.255.0.0     UG    0      0        0 eth0.800
192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth1

Table de routage IPv6 du noyau
Destination                    Next Hop                   Flag Met Ref Use If
fc00::/12                      fcab::2                    UG   1024 0     0 eth0.800
fcab::/112                     ::                         U    256 0     1 eth0.800
fcac::/112                     ::                         U    256 0     0 eth0.267
fcee:dead:babe::1/128          ::                         U    256 0     0 eth0.800
fcff:dead:beef::1/128          ::                         U    256 0     0 eth0.267
fe80::/64                      ::                         U    256 0     0 eth0
fe80::/64                      ::                         U    256 0     0 eth0.800
fe80::/64                      ::                         U    256 0     0 eth0.267
fe80::/64                      ::                         U    256 0     0 eth1
::/0                           ::                         !n   -1  1   866 lo
::1/128                        ::                         Un   0   1  1001 lo
fcab::1/128                    ::                         Un   0   1     0 lo
fcac::1/128                    ::                         Un   0   1     0 lo
fcee:dead:babe::1/128          ::                         Un   0   1     0 lo
fcff:dead:beef::1/128          ::                         Un   0   1     0 lo
fe80::221:91ff:fe8c:e863/128   ::                         Un   0   1     0 lo
fe80::221:91ff:fe8c:e863/128   ::                         Un   0   1     0 lo
fe80::221:91ff:fe8c:e863/128   ::                         Un   0   1     0 lo
fe80::f24d:a2ff:fe2c:5e6a/128  ::                         Un   0   1     0 lo
ff00::/8                       ::                         U    256 0     0 eth0
ff00::/8                       ::                         U    256 0     0 eth0.800
ff00::/8                       ::                         U    256 0     0 eth0.267
ff00::/8                       ::                         U    256 0     0 eth1
::/0                           ::                         !n   -1  1   866 lo
\end{verbatim}

\newpage

\subsection{\label{API}API Zabbix}

		\subsubsection{Script Perl}
		\vspace{0.3cm}
\begin{verbatim}

#!/usr/bin/perl

use 5.010;
use strict;
use warnings;
use JSON::RPC::Client;
use Data::Dumper;

#-------------------------------------------
# Authentification sur le serveur Zabbix
#-------------------------------------------

my $client = new JSON::RPC::Client;
my $url = 'http://192.168.1.35/zabbix/api_jsonrpc.php'; #URL de connection
my $authID;
my $response;

#-------------------------------------------
#Déclaration de la variable $json en identifiant la version de json utilisée, la méthode utilisée le login et le mot de passe.
#-------------------------------------------

my $json = {
jsonrpc => "2.0",
method => "user.login",
params => {
user => "admin",
password => "pwasrall"
},
id => 1
};

$response = $client->call($url, $json);

#-------------------------------------------
# Check si la réponse est OK
#-------------------------------------------

die "Fail Authentication\n" unless $response->content->{'result'};

$authID = $response->content->{'result'};
print "Authentication Success. Auth ID: " . $authID . "\n";

#-------------------------------------------
# Création de la requête JSON-RPC ici un appel à la modèle graph.get avec comme nom de graphique CPU sur l'hôte Zabbix-server
#-------------------------------------------

$json = {
   jsonrpc=> '2.0',
   "method"=>"graph.get",
   "params"=>{
      "output"=>"extend",
      "search"=>{
         "name"=>"CPU"
      },
      "filter"=>{
         "host"=>[
            "Zabbix-server"
         ]
      },
      "limit"=>2
   },
   id => 2,
   auth => "$authID",
};
$response = $client->call($url, $json);

#-------------------------------------------
# Check si la réponse est OK
#-------------------------------------------

die "graph.get failed\n" unless $response->content->{result};

#-------------------------------------------
#Affichage de la réponse
#-------------------------------------------

print "Liste de graphe\n-----------------------------\n";
foreach my $host (@{$response->content->{result}}) {
print  "Graphe: ".$graph->{"name"}."\n";

\end{verbatim}

\newpage

		\subsubsection{Script PHP}
		\vspace{0.3cm}

\begin{verbatim}

<?php

//----------------------------
// Chargement ZabbixApi
//----------------------------

require 'ZabbixApiAbstract.class.php';
require 'ZabbixApi.class.php';

try {

//----------------------------
// connection à l'API Zabbix 
//----------------------------

		    $api = new ZabbixApi('http://192.168.1.35/api_jsonrpc.php','zabbix','pwasrall');

//----------------------------
// Récupération de tous les graphes
//----------------------------

			$graphs = $api->graphGet();

//----------------------------
// Affichage des valeurs ID des graphiques
//----------------------------
			
			foreach($graphs as $graph)
				echo $graph->graphid."\n";

} catch(Exception $e) {

// Exception in ZabbixApi catched
	    echo $e->getMessage();

}


?>
\end{verbatim}

	\subsection{RRDTool}

		\subsubsection{Script}
		\vspace{0.3cm}

Script de génération des graphiques RRD depuis les valeurs de la base de donnée de Zabbix.\\

\begin{verbatim}

#!/usr/bin/perl

use warnings;
use strict;
use Encode;
use utf8;
use DBI;
use Date::Parse;




#-------------------------------------------
#Déclaration des variables pour la connection à la base et déclaration des tableaux de stockage des
données.
#-------------------------------------------

my $bd = 'zabbix';
my $serveur = 'localhost';
my $id = 'root';
my $mdp = 'pwasrall';
my $port = '';
my $i=0;
my @result_horloge = ();
my @result_network = ();
my $date;

#-------------------------------------------
#Connection à la base de donnée MYSQL de Zabbix
#-------------------------------------------

print " BASE CONNEXION : $bd\n";
my $dbh = DBI->connect("DBI:mysql:database=$bd;host=$serveur;port=$port",$id,$mdp,{ RaiseError => 1, }
) or die "Connection impossible BASE $bd !\n $! \n $@\n$DBI::errstr";

#-------------------------------------------
#Préparation de la requête SQL pour la récupération des données dans la base de Zabbix
#-------------------------------------------

print "Affichage des valeurs de debit entrant sur eth0 de la machine service \n";

my $requete_network = <<"SQL"; 

SELECT value,clock
FROM history_uint 
WHERE itemid = 23331 AND (clock < (SELECT MAX(clock) FROM history_uint WHERE itemid = 23331) AND clock >
(SELECT (MAX(clock)-1000) FROM history_uint WHERE itemid = 23331));

SQL

#-------------------------------------------
#Lancement de la requête SQL et récupération des valeurs ligne à ligne
#-------------------------------------------

my $prep = $dbh->prepare($requete_network) or die $dbh->errstr;
$prep->execute() or die "Echec de la requete : $requete_network\n";

print "RESULTAT DEBIT NETWORK: \n";
while ( my $refdonnees= $prep->fetchrow_hashref) {
	print "\t $refdonnees->{clock}:$refdonnees->{value}\n";
	push(@result_horloge,$refdonnees->{clock});
	push(@result_network,$refdonnees->{value});
}

$prep->finish(); 

#-------------------------------------------
#Création de la base RRD, mise à jour des données de la base et génération du graphique
#-------------------------------------------

my $test_clock = $result_horloge[0]-1;
my $create_rrd = "rrdtool create test.rrd --start $test_clock DS:test:GAUGE:600:U:U RRA:AVERAGE
:0.5:1:12";
print "Creation de la base de donnee RRD et config du graphique\n";
print `$create_rrd`;


my $size = $#result_horloge+1;

print "$size\n";
my $update_rrd = "rrdtool update test.rrd ";

for($i=0 ;$i<$size;$i++)
{
	$update_rrd = "$update_rrd $result_horloge[$i]:$result_network[$i]"; 
} 
print `$update_rrd`;

print "Generation du graphique\n";
my $gen_graph =  "rrdtool graph test.png -s $test_clock -e $result_horloge[$size-1] -h 300 -w 600 -t
 \"Graphe de test\" DEF:test=test.rrd:test:AVERAGE LINE3:test#FF0000:\"TEST\"";
print `$gen_graph`;

$date= str2time('10/03/2014 00:00:00');
print "$date \n";


\end{verbatim}

\newpage

	\subsection{\label{docLDN}Documentation pour LDN}

		\subsubsection{Installation de Zabbix serveur et agent}

	\vspace{0.3cm}

	\#\# Zabbix-server\\
	\# wget http://repo.zabbix.com/zabbix/2.0/debian/pool/main/z/zabbix-release/zabbix-release\_2.0-1wheezy\_all.deb\\
	\# dpkg -i zabbix-release\_2.0-1wheezy\_all.deb\\
	\# apt-get update\\
	\# apt-get install zabbix-server-mysql zabbix-frontend-php\\

	\#\# Zabbix-agent (sur la cible)\\
	\# wget http://repo.zabbix.com/zabbix/2.0/debian/pool/main/z/zabbix-release/zabbix-release\_2.0-1wheezy\_all.deb \\
	\# dpkg -i zabbix-release\_2.0-1wheezy\_all.deb \\
	\# apt-get update \\
	\# apt-get install zabbix-agent \\
	\#\# Ajout de l'IP du serveur dans le fichier conf de l'agent
	\# vim /etc/zabbix/zabbix agentd.conf +86
		\subsubsection{Configuration/création des graphiques prototypes}

\begin{center}

		\includegraphics[width=15.5cm]{95centil2.png}

		\vspace{0.3cm}

\end{center}

	\# Menu Configuration/Modèles/Template OS Linux/Découverte/Network interface/graph prototype \\
	\# Création de graphique\\
	\# Configuration de la valeur du centile gauche et droit (95.00)\\
	\# Sélection des éléments à récupérer (débit entrant et sortant des interfaces réseau)\\
	\# Création des graphiques lors de la prochaine mise à jour des hôtes. \\

		\subsubsection{Configuration/création des déclencheurs prototypes}
		\vspace{0.3cm}

	\# Menu Configuration/Modèles/Template OS Linux/Découverte/Network interface/déclencheurs prototypes \\
	\# Création des déclencheurs \\


\begin{center}

		\includegraphics[width=10cm]{declencheur1.png}

		\vspace{0.3cm}

\end{center}

	\# Configuration des éléments en cliquant sur sélectionner prototype \\

\begin{center}

		\includegraphics[width=10cm]{declencheur2.png}

		\vspace{0.3cm}

\end{center}

	\# Sélection de l'élément souhaité : Incomming network traffic on \{\#IFNAME\}.\\
	\# Configuration de l'expression : la dernière (plus récente) valeur T est > N \\
	\# Choix de Dernier (T) : 1 \\
	\# Choix de N = valeur du centile\\
	\# Création du nouveau déclencheur lors de la prochaine mise à jour des hôte. \\

\newpage
	
\subsection{\label{action}Image de configuration de l'action}

	\begin{center}
		\includegraphics[scale=0.8]{action1.png}
	\end{center}

\newpage

\subsection{\label{sniffer}Script Sniffer}

\vspace{0.3cm}

\begin{verbatim}

#!/usr/bin/perl

use strict;
use Net::Pcap;
use NetPacket::Ethernet;
use NetPacket::IP;
use NetPacket::TCP;


# Variable Declarations
my $filter_t;
my ($tcp,$ip,$ethernet);
my ($net,$mask,$err);
my $dev = $ARGV[0]; #takes the network card interface as the first parameter
my $dev2 = $ARGV[1]; #takes the network card interface as the second parameter
my $filter;
my $optimize = 1;
my $pid;


# Determine network number and mask for use later on when we're compiling our filter
if (Net::Pcap::lookupnet($dev, \$net, \$mask, \$err) == -1){
die 'Cannot determine network number and subnet mask - ' , $err;
}

if (Net::Pcap::lookupnet($dev2, \$net, \$mask, \$err) == -1){
die 'Cannot determine network number and subnet mask - ' , $err;
}
 
$pid = fork();
if ($pid != 0) {
#Dans le père
 

my $pcap_object = Net::Pcap::open_live($dev, 1500, 0, 0, \$err);
if (defined $err){
die 'Failed to create live capture on - ' , $dev , ' - ', $err;
}

Net::Pcap::compile($pcap_object, \$filter_t, $filter, $optimize, $mask); #compile our filter ,$filter
 and return it in the $filter_t variable
 
Net::Pcap::loop($pcap_object, -1, \&capture_packets, '') || die 'Unable to perform packet capture'; 
#loop or sniff packets on the network infinitly

Net::Pcap::close($pcap_object); #close the pcap object gracefully
 
 } else {
#Dans le fils
 
 my $pcap_object_2 = Net::Pcap::open_live($dev2, 1500, 0, 0, \$err);
if (defined $err){
die 'Failed to create live capture on - ' , $dev2 , ' - ', $err;
}

Net::Pcap::compile($pcap_object_2, \$filter_t, $filter, $optimize, $mask); #compi    le our filter ,
$filter and return it in the $filter_t variable
 
Net::Pcap::loop($pcap_object_2, -1, \&capture_packets, '') || die 'Unable to perform packet capture';

 #loop or sniff packets on the network infinitly
 
Net::Pcap::close($pcap_object_2); #close the pcap object gracefully
exit(0);

}
 
# subroutine to handle each packet that is sniffed
sub capture_packets {
my($user_data, $hdr, $pkt) = @_; #this line should always be present to handle the incoming packets, 
You refer to the incoming packets from $pkt as you would see f    rom the next lines of code
my $ethernet = NetPacket::Ethernet->decode($pkt); #decodes the ethernet frame
my $ip = NetPacket::IP->decode($ethernet->{data}); # decodes the IP headers
my $tcp = NetPacket::TCP->decode($ip->{data}); # decodes the TCP data 

if($pid!=0){
print "INTERFACE eth0.800 \n";

if($ip->{src_ip}=~ /172\.16\..*$/){
print "OUT($ip->{src_ip}): $ip->{len} octets\n";
}
else {
print "IN($ip->{dest_ip}): $ip->{len} octets\n";
}
print "IP Source : $ip->{src_ip} -> IP Destination : $ip->{dest_ip} : "; # prints source to destination 
IP's
print ": $ip->{len} octets\n"; #prints the data contained in this packet
} else {
print "INTERFACE eth0.267\n";
 
if($ip->{src_ip}=~ /172\.16\..*$/){
print "OUT($ip->{src_ip}): $ip->{len} octets\n";
}
else {
print "IN($ip->{dest_ip}): $ip->{len} octets\n";
}
print "IP Source : $ip->{src_ip} -> IP Destination : $ip->{dest_ip} : "; # prints source to destination 
IP's
print ":$ip->{len} octets\n"; #prints the data contained in this packet
}
}
\end{verbatim}

\newpage
